
Interaction_Model <- function(train_set,test_set,para,remove_terms,response,asset_group){
  
  # Fit the Two Stage Lasso model 
  #
  # Arg:
  #  train_set: train model on train dataset 
  #  test_set: predict the response variable on test dataset
  #  para: a vector of length 2. represent the two parameters in two stages
  #  remove_terms: the interaction terms that has low coverage on (train_set, test_set)
  #                so that you don't want to consider them in your model
  #  response: a character. response variables you choose. eg: "FUT_12W_RLT_RET"
  #  asset_group: define the asset group you want to include in th model. 
  #               It can be a character or a vector. Eg: "SECTOR","INDUSTRY_GROUP",c("SECTOR","INDUSTRY_GROUP")
  # 
  # Return:
  #  a list. list[[1]] is the test dat with an addtion y_hat column, where y_hat is the predicted y
  #          list[[2]] is the significant interactions generated by stage 2
  
  ##################################################################################
  ########################### Fit Two stage lasso on train_set  ####################
  ##################################################################################
  # preprocess the data
  ana.data <- Two_stage_preprocess(train_set,response)
  # No missing data is required
  ana.data <- ana.data[complete.cases(ana.data),]
  
  ###################  Stage 1 ######################
  # only LOI_ would be put as covariates
  X1 <- ana.data %>% select(starts_with(c("LOI_"))) # all LOI_ 
  # relocate X1
  X1 <- X1 %>% relocate(LOI_18600,LOI_18400)
  Y <- ana.data[,1] # according to the return of Two_stage_preprocess(), y is in the first col
  fit1 <- coef(glmnet(as.matrix(X1),Y,lambda=para[1],
                      penalty.factor=c(0,0,rep(1,dim(X1)[2]-2)))) # get the coef of the model
  #fit1 <- coef(glmnet(as.matrix(X1),Y,lambda=para[1],standardize=FALSE)) # get the coef of the model
  
  # extract the LOI_ that has non-zero coef
  fit1 <- as.data.frame(as.matrix(fit1))
  fit1[,"variable"]<- rownames(fit1)
  Stage2_vari <- fit1[which(abs(fit1$s0)>0),"variable"] # choose variables that has coef != 0
  Stage2_LOI <- Stage2_vari[-1] # remove the intercept 
  
  ################## Stage 2 ##########################
  if(identical(Stage2_LOI,character(0))){
    print("No significant LOI_ main effect, please select a smaller lambda")
  }else{
    cols <- colnames(ana.data)
    #factor_names <- cols[grepl('^LOI_', cols)] # all LOI_name
    len_asset_gp <- length(asset_group)
    if(len_asset_gp == 1){
      Stage2_group <- levels(train_set[[asset_group]])
    }else{
      Stage2_group <- c(levels(train_set[[asset_group[1]]]),
                        levels(train_set[[asset_group[2]]]))
    }
    #Stage2_group <- setdiff(cols,c("Y",factor_names)) # all asset groups
    
    # only keep the industry_group
    # LOI,region,sector,industry
    # numcol <- length(cols)
    # Stage2_group <- cols[(numcol-24):numcol]
    # generate the names of all possible interaction terms between LOI_ from stage 1 and asset group
    Interaction_term <- expand.grid(Factor = Stage2_LOI, Group = Stage2_group)
    # remove the interactions that has low coverage
    Interaction_term <- setdiff(Interaction_term,remove_terms) 
    inter_names <- paste0(Interaction_term$Factor,"*",Interaction_term$Group)
    
    # generate the cols of possible interaction terms between LOI_ from stage 1 and asset group
    V1 <- Stage2_LOI[1]
    inter_dat <- ana.data[,V1]* ana.data[,Stage2_group]
    colnames(inter_dat) <- paste0(V1,"*",Stage2_group)
    for(i in 2:length(Stage2_LOI)){
      V1 <- Stage2_LOI[i]
      temp <- ana.data[,V1]* ana.data[,Stage2_group]
      colnames(temp) <- paste0(V1,"*",Stage2_group)
      inter_dat <- cbind(inter_dat,temp)
    }
    # remove the interactions that has low coverage 
    inter_dat <- inter_dat[,inter_names]
    
    # cbind the significant LOI_ and the interactions terms
    X2 <- cbind(ana.data[,Stage2_LOI],inter_dat)
    X2 <- X2 %>% relocate(LOI_18600,LOI_18400)
    
    # fit lasso regression in stage 2
    #m_lasso <- glmnet(as.matrix(X2),Y,lambda=para[2],standardize=FALSE)
    m_lasso <- glmnet(as.matrix(X2),Y,lambda=para[2],
                      penalty.factor=c(0,0,rep(1,dim(X2)[2]-2)))
    
    # get coef and extract the non-zero terms
    fit2 <- coef(m_lasso)
    fit2 <- as.data.frame(as.matrix(fit2))
    fit2[,"variable"]<- rownames(fit2)
    Inter_vari <- fit2[which(abs(fit2$s0)>0),"variable"]
    Inter_vari <- Inter_vari[-1]
    
    # get the non-zero interaction terms from non-zero terms
    # that is, the significant interaction terms 
    Inter_vari <- Inter_vari[Inter_vari %in% inter_names] 
    
    ##################################################################################
    ########################### Test Two stage lasso on test_set  ####################
    ##################################################################################
    
    # after we finish the two-stage on train set, we can fit the model
    # from stage 2 on the test dat to get predicted y
    if(identical(Inter_vari,character(0))){
      print("No significant interaction terms in stage 2, please select a smaller lambda")
      return(list("No_stage_2",NULL))  
    }else{
      ################ Prepare test dat ####################
      # To predict, test dat should have same format as X2 in stage 2
      ana.test <- Two_stage_preprocess(test_set,response)
      # repeat the steps of creating interaction cols as what we did in stage 2
      V1 <- Stage2_LOI[1]
      inter_dat_test <- ana.test[,V1]* ana.test[,Stage2_group]
      colnames(inter_dat_test) <- paste0(V1,"*",Stage2_group)
      for(i in 2:length(Stage2_LOI)){
        V1 <- Stage2_LOI[i]
        temp <- ana.test[,V1]* ana.test[,Stage2_group]
        colnames(temp) <- paste0(V1,"*",Stage2_group)
        inter_dat_test <- cbind(inter_dat_test,temp)
      }
      inter_dat_test <- inter_dat_test[,inter_names]
      X_test <- cbind(ana.test[,Stage2_LOI],inter_dat_test)
      #X_test <- X_test %>% relocate(LOI_18600,LOI_18400)
      # predict on test dat
      test_set$y_hat <- predict(m_lasso, newx = as.matrix(X_test))
      # rename the FUT_12W_RLT_RET to y 
      test_set <- test_set %>%
        rename(y = response)
      
      ##################################################################################
      ########################### Return a list  #######################################
      ##################################################################################
      
      return(list(test_set,Inter_vari))  
    }
  }
}